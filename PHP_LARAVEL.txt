1) В Laravel есть master-шаблон (master.blade.php), на основе которого наследуются все остальные страницы. В мастер шаблон также могут инклюдиться другие шаблоны
	@include($template.'.layouts.preconnect') – вставляет готовый файл в шаблон из пути указанного внутри. Где $template.'.layouts папки, а preconnect непосредственно сам блэйд шаблон.
	@extends($template.'.layouts.master') – используется на странице, которая использует мастер шаблон. Т.е. $template.'.layouts.master' ссылка на мастер шаблон, который будет основой для новой страницы. Ставится в самом начале на новой странице (дочернем шаблоне).
	@yield('main_container_class', 'col-md-9') – в шаблоне также могут быть такие строки. main_container_class название «компонента», col-md-9 значение по умолчанию. Это своего рода маркер, который указывает, что в этом участке будет такое содержимое (col-md-9). Используется в паре с другой директивой =>
	@section('main_container_class', 'col-md-12') – в это означает, что на отдельной странице использующей мастер шаблон, у этого «компонента» main_container_class содержимое будет col-md-12', вместо значения по умолчанию (col-md-9) описанного у родительского шаблона
@yield('main') – возможен такой вариант. Тут в шаблон вставляется объемный кусок кода =>
@section('main') какой-то код... @endsection – в «компонент» 'main' вставляем какое-то содержимое (для каждой страницы может быть свое, как и в примере по @section выше)
@show – директива пишется вместо @endsection, в случае если после объявления блока @section(…) надо сражу же вывести это содержимое. Т.е. это короткий аналог @section(‘some_section’) …@endsection + @yield(‘some_section’)
@parent – директива пишется внутри @section и она означает, что страница полностью наследует содержимое из шаблона. Кроме того после @parent можно указать добавочное содержимое
@include(…) – добавляет содержимое описанное в отдельном файле. Кроме того, вторым аргументом можно передавать переменные которые будут доступны во вставляемом содержимом

2) Образец:
{{-- Recursive include --}}
@include($template . '.store_reviews.branch_item', [
    'branchReview' => $branchReviews->first(),
    'branchReviews' => $branchReviews->slice(1)
])
В данном примере рекурсивно вызывается содержимое инклюда, но вставляется только первый элемент (метод first()), затем этот первый элемент удаляется (методом slice(1))

3) Запись вида:
['entity' => 'branch_reviews', 'model' => $branchReview]
Это массив в php. По сути => охначает присваивание, т.е. в ‘entity’ присваивается значение ‘branch’, в ‘model’ присваивается значение переменной $branchReview. Кроме того в php массивы могут отображаться по другому, например:
['someValue1' , 'someValue2']
В данному случае по индексу ‘0’ лежит значение ‘someValue1’, по индексу ‘1’ лежит значение ‘someValue2’

4) В php можно наюлюдать такой символ ->
Он используется только на объектах для получения доступа к свойству объекта. При этом надо понимать, что объекты в Php в отличии от Js создаются только через class. Пример:
$branchReviews->first()
Мы вызываем у объекта $branchReviews (объект обязательно инстанс какого-то класса), метод first()

5) Чтобы переменная в шаблоне работала она должна быть определена
Например в шаблоне есть переменная $description, значит она должна быть определена в этом шаблоне
@php $description = $collection->getDomainbleDescriptionByDomain($domainId, true); @endphp

6) В директивы @include можно передавать свои атрибуты. Пример:
@include($template.'.articles.categories', ['detail' => true])
<nav class="categories-nav @if(isset($detail)) categories-nav--article @endif">

7) Оператор разрешения области видимости - ::
Оператор используется для вызова статических методов/свойств класса (т.е. внутри класса). Пример если используем снаружи:
SomeClassName::someStaticMethod()
Пример если используем внутри класса:
self::someStaticMethod()

8) parent позволяет использовать свойства/методы/конструктор родителя. Пример:
//Пример в конструкторе
Function __construct($name, $value) {
	Parent::__construct($name) {…}
}

//Пример в методе
Function getInfo() {
	$information = parent::getInfo();
	$information .= “{$this->info}”;

	Return $information;
}

Довольно хорошо расписано тут: http://evilcoderr.blogspot.com/2013/12/this-self-php.html

9) КУКИ И СЕССИИ
а) Если Куков нет на компе клиента, то с помощью Set-Cookie куки устанавливаются
б) После того как куки установлены, каждый раз когда открывается эта страница  - браузер отправляет значения этих куков на сервер
в) Когда открывается сессия, генерируется уникальное случайное число (идентификатор сессии)
г) Пользователю передается это идентификатор через куки и при последующих запросах эти куки возвращаются на сервер (пункт Б). Именно по этом идентификатору сервер будет определять какой пользователь перед ним и соответственно выдавать нужные данные в массиве $_SESSIONS
Довольно подробно просессии можно прочитать тут: http://komotoz.ru/uroki/php/sessii_v_php.php http://weblecture.ru/node/152

10) Тело запроса может быть только если запрос осуществлен методом POST

11) Элементы класса могут быть:
	Public – свойства и методы доступны везде
	Protected – свойства и методы доступны только внутри класса, либо внутри класса наследника
	Private – свойства и методы доступны только внутри класса

12) В Laravel есть макросы, позволяющие добавлять методы классы (но не через наследование). Пример (В класс Collection добавляется макрос-функция toUpper):
 
13) Если сломался Поиск, надо заного переиндексировать. Для этого winpty -> php artisan elasticsearch:generate_index --name=products

14) Передача переменных в trans
{!!  trans('orders/front.redirect_to_payment_message', ['seconds' => '<span id="countdown">5</span>']) !!}

'redirect_to_payment_message' => 'You will be transferred to the payment page in :seconds seconds',



